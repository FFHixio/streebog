GOST R 34.11-2012 hash function with 512/256 bit digest
=======================================================

About
-----
This is portable implementation of the GOST R 34.11-2012 hash function. The
standard for this hash function developed by the Center for Information
Protection and Special Communications of the Federal Security Service of the
Russian Federation with participation of the Open joint-stock company
"Information Technologies and Communication Systems" (InfoTeCS JSC).

Requirements
------------
* GCC, Clang or ICC compiler supporting 64-bit integers.

* GNU make (or any compatible make).

Compile and install
-------------------
The software is smart enough to detect the most suitable configuration for
running hardware and software platform. In almost all cases it is sufficient
just to type 'make' on top of the source directory:

# make
gcc46 -g -O2 [other compile options..]

This will configure and compile a binary program file named 'gost3411'.

Usage instructions
------------------

# ./gost3411 -h
usage: [-25bhqrt] [-s string] [files ...]

Flags:
 -2 - 256-bit digest.
 -5 - 512-bit digest (default).
 -t - Testing mode to produce hash for example messages defined in standard.
 -b - Benchmark mode (to see how fast or slow this implementation works).
 -s - Print a checksum of the given string.
 -r - Reverses the format of the output. This helps with visual diffs.
 -q - Quiet mode - only the checksum is printed out.

Each file listed on the command line is processed and hash is printed for each
one. Stdin is read as input when executed without arguments.

Compile-time options
--------------------
By default, compiler set in 'CC' environment variable is used, falling back to
'cc' unless set. You can quickly recompile source with another compiler by
setting CC:

# make CC=clang

Special target called 'remake' may need to be used to overwrite recently
compiled up-to date binary:

# make remake CC=icc

This will recompile sources from scratch using Intel C Compiler with default
flags. If you need to adjust these compiler flags, try to set them with CFLAGS
knob:

# make remake CC=icc CFLAGS="-O3"

API
---
The API to this implementation is quite straightforward and similar to other
hash function APIs. 

GOST3411Context
    This is the hash context. There should be one GOST3411Context for each
    object to be hashed.

GOST3411Context *
GOST3411Init(const unsigned int digest_size);
    Allocates necessary amount of memory for hash object and return pointer to
    a GOST3411Context of specified hash size (digest_size). Digest size can be
    either 512 or 256.

void
GOST3411Update(GOST3411Context *CTX, const unsigned char *data, size_t len);
    Hash some data in memory of "len" bytes size. Address of "data" must be
    16-byte aligned. The best performance results are achieved when len is
    multiple of 64.
    
    Note that this call does not modify original data in memory. If security
    is an issue, calling application should destroy that memory block right
    after GOST3411Update(), by e.g. memset() to zero.

void
GOST3411Final(GOST3411Context *CTX);
    Finalizes hashing process and get GOST R 34.11-2012 hash in
    CTX->hashdigest.

void
GOST3411Destroy(GOST3411Context *CTX);
     The data in context including hash itself, buffer and internal state
     zeroed-out. Every pointer and memory block are freed afterwards. Context
     totally destroyed and the object can't be used anymore.

Example
-------
    #include "gost3411-2012-core.h"

    ...

    GOST3411Context *CTX;

    ...
        CTX = GOST3411Init(512);
        ...
        GOST3411Update(CTX, buffer, (size_t) bufsize);
        ...
        GOST3411Update(CTX, buffer, (size_t) bufsize);
        ...
        /* call GOST3411Update() for each block of data */
        ...
        GOST3411Final(CTX);
        ...
        printf("Digest = %s\n", CTX->hexdigest);
        ...
        GOST3411Destroy(CTX);
    ...


Portability notes
-----------------
...

Platforms tested
----------------
FreeBSD x86/x86_64
Linux   x86/x86_64
Linux   powerpc
Darwin  x86_64

Performance
-----------
To measure performance of this implementation SUPERCOP toolkit has been used. 

Intel(R) Pentium(R) CPU G6950 @ 2.80GHz    x86: 40 cycles per byte ( 70 MB/s)
Intel(R) Pentium(R) CPU G6950 @ 2.80GHz x86_64: 36 cycles per byte ( 78 MB/s)
Intel(R) Xeon(R)    CPU X5650 @ 2.67GHz x86_64: 31 cycles per byte ( 84 MB/s)
Intel(R) Xeon(R)    CPU X5675 @ 3.07GHz x86_64: 29 cycles per byte (104 MB/s)

Author
------
Alexey V. Degtyarev <alexey@renatasystems.org>
